 %!TEX root = ../dokumentation.tex

\chapter{Introduction}\label{cha:Introduction}

\paragraph{Explanation of debugging}
\label{paragraph:debuging}

"Debugging is the process of locating and removing faults in computer programs" according to \myCite{Collins_debugging.2014}. The steps that are part of the debugging process are reproducing the problem, identifying the source of the problem and fixing the problem. All of these steps can be done manually but there are ways to improve and accelerate this process.

To find problems there is the option of writing automated tests, inserting debug outputs on the console into the source code or writing states into log files. This enables the programmer to find anomalies before, while and after running the program.

When a way is found to reproduce the problem, to find the source of it the manual way is to increase the amount of debug outputs around the problematic part of the code and confine the point in the code at which the error occurs.

"Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?" according to \myCite{Kernighan.1982}. As this states, debugging is a quite exhausting and time consuming task. For that reason for most programming languages there are tools to aid the programmer to narrow down the source of the bug with following methods:

\begin{itemize}

\item Enabling the user to set breakpoints at which the program pauses and he can inspect the values of the variables directly within the code. By continuing the program to move to the next breakpoint or by going forward through the code step by step the point where the error occurs can be found. It is also possible to be able to add conditions to the breakpoints describing a state that has to be fulfilled for the debugger to pause. \myCite{Undo.2019}


\item Have the code throw an exception when unwanted behavior occurs and stop at this exception. By saving a stack of the calls which occurred before the exception was thrown or dumping the buffer, the programmer can retrace where the error may be found.\myCite{Jetbrains.2019}


\item Reverse debugging records all program activities and thereby it is possible to move backwards in addition to forward stepping from a set breakpoint and see the changes in the variables and the calls in the code leading to the problem.\myCite{Undo.2019}

\end{itemize}

When the source of the problem is found the final step of fixing the problem is to correct the code.

\paragraph{Problem with debugging shaders in the graphics pipeline}
\label{section:problems}

A shader is a program running on the GPU thereby mostly running as part of the graphics pipeline also known as rendering pipeline.\myCite{Khronos_shader.2019} The exception for this behavior is the compute shader which is independent from the graphics pipeline.\myCite{Khronos_compute.2019}

There are ways to debug shaders on the graphics pipeline, as shown in Section \ref{section:debuggingMethods}, but there are no general solutions for aiding the user in this debugging process.\myCite{Ciardi.2015}

While most CPUs are very broad in their functionality and support debugging by itself a GPU is more specialized in the way it functions and usually does not have the option to pause the code to enable inspections at runtime and does not even have access to a console or logger to write states into.\myCite{Fox.2017} As explained in more detail in Section \ref{section:debuggingMethods_drivers} it is possible to enable debugging on the GPU with specialized drivers for specific hardware.\myCite{Nvidia_debug.2019}\myCite{Microsoft_debug.2016}

\paragraph{Existing approaches for compute shaders}

There are approaches which enable debugging of compute shader code by translating it from another language in more detail. The code is written in a debuggable language for the CPU, so it can be debugged running on the CPU. The code is then translated to the shader language and run as a compute shader on the GPU.
See more in section \ref{section:computeApproaches}.

\paragraph{Objective of creating a general solution for debuging shaders in the graphics pipeline}

The objective of this work is to create a general solution to enable debugging of shaders within the graphics pipeline. The goals this solution should fulfill are the following:

\begin{itemize}
	\item The different methods shown to assist the programmer in debugging mentioned in Section \ref{paragraph:debuging} are usable.
	\item The solution is not dependent on using specific graphics cards or drivers.
	\item It is possible to switch between a mode where debugging is enabled and a mode where the shaders run as usual, so the program can run with the full performance and without interference of the debugger.
	\item The resulting output per render iteration of the debugger is close to the output of the program with the undebugged shader. It is close enough that the programmer can see what the rendering result without the debugger would look like. Errors like those resulting from the use of float variables with their inaccuracies are tolerable because there are tolerances within human perception where minimal changes in position or color within a rendered result do not matter.\myCite{Franz.2006}
	\item Performance is not a major requirement while running the debugger. It is possible to see the output and the values of the shader within each frame and iterate through the frames. It is not necessary to view the result in the speed of the final application while debugging. The programmer uses time to inspect the values within the shader which would not be possible with changing variables at high speeds like the 60 frames per second a usual graphics application has.\myCite{Christensson.2015} The debug application should fulfil acceptable response times for user interfaces. "10 seconds is about the limit for keeping the user's attention focused on the dialogue." according to \myCite{Nielson.1993}.
\end{itemize}




